### 前言

小提示：阅读本篇内容，至少需要了解double和float的二进制表示。



书中的代码示例如下：



```c
#include <stdio.h>
  
int main(void)
{
  float a,b;
  
  b = 2.0e20 + 1.0;
  a = b - 2.0e20;
  printf("%f \n",a);
  
  return 0;
}
```



我的测试环境如下所示，在该测试环境中，a等于 4008175468544.000000。

```vim
Linux version 5.15.0-134-generic (buildd@lcy02-amd64-092) (gcc (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0, GNU ld (GNU Binutils for Ubuntu) 2.34) #145~20.04.1-Ubuntu SMP Mon Feb 17 13:27:16 UTC 2025
```

为什么会产生这样的结果呢？由于书中的解释不够详细，所以我在阅读至此处时，自然而然产生了想要深入研究的想法，遂将研究结果写为本篇博客，供大家参考。



针对这个问题，我的思路是，逐行分析每一句代码都产生了什么效果，或许就可得知误差出现在哪里。下面开始逐行分析：

### 逐行分析解读

首先是第一行：

```c
b = 2.0e20 + 1.0;
```

先从右边的计算，2.0e20 + 1.0 开始：

首先，2.0e20会被当作double类型的数据进行处理，根据double变量的存储规则，它的底层二进制如下：

0-10001000010-0101101011110001110101111000101101011000110001000000

其中：

* 符号位：0

* 指数部分：10001000010

* 尾数部分：0101101011110001110101111000101101011000110001000000

这个二进制是如何计算得出的呢？下面我们继续讲解。

将2*10^20进行质因式分解：

2 * 10^20 = 2*(2*5)^20



指数部分的10001000010，转化为十进制为1090。按照IEEE 754双精度指数偏移量1023来计算，实际的指数为，1090 - 1023 = 67。

尾数部分





其次，1.0也会被当作double类型来接收，底层二进制如下：

0 01111111111 0000000000000000000000000000000000000000000000000000

可以用这个函数直接打印二进制：

```c
#include <stdio.h>
#include <stdint.h>

void print_bits_float(float f)
{
    union {
        float a;
        uint32_t b;
    }c;
    c.a = f;

    for (int i = 0; i < 32; i++) {
        printf("%d", c.b & 1 << (31 - i) ? 1 : 0);

        if (i == 0 || i == 8)
            printf(" ");
    }
    printf("\n");
}


void print_bits_double(double d) 
{
    union {
        double a;
        uint64_t b;
    }c;
    c.a = d;

    for (int i = 0; i < 64; i++) {
        //caution! 1ULL not 1 because 1 << or >> more than 31 is undefined behaviour.
        printf("%d", c.b & (1 ULL << (63 - i)) ? 1 : 0);

        if (i == 0 || i == 11)
            printf(" ");
    }
    printf("\n");
}
```

接着做浮点数的加法运算，具体运算规则是这样的：

1. 小阶 对齐 大阶&#x20;

2. 小阶数的小数点移动一下&#x20;

3. 相加/相减&#x20;

4. 把结果转换为规范数

