### 前言

小提示：阅读本篇内容，至少需要了解double和float的二进制表示。

书中的代码示例如下：

```
#include <stdio.h>

int main(void)
{
  float a,b;

  b = 2.0e20 + 1.0;
  a = b - 2.0e20;
  printf("%f \n",a);

  return 0;
}
```

我的测试环境如下所示，在该测试环境中，a 等于 4008175468544.000000。

```
Linux version 5.15.0-134-generic (buildd@lcy02-amd64-092) (gcc (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0, GNU ld (GNU Binutils for Ubuntu) 2.34) #145~20.04.1-Ubuntu SMP Mon Feb 17 13:27:16 UTC 2025
```

为什么会产生这样的结果呢？由于书中的解释不够详细，所以我在阅读至此处时，自然而然产生了想要深入研究的想法，遂将研究结果写为本篇博客，供大家参考。

针对这个问题，我的思路是，逐行分析每一句代码都产生了什么效果，或许就可得知误差出现在哪里。下面开始逐行分析：

### 逐行分析解读

首先是第一行：

```
b = 2.0e20 + 1.0;
```

先从右边的计算 2.0e20 + 1.0 开始，我们首先需要把这两个常量的二进制表示出来，然后做浮点数加法运算。

#### 2.0e20 和 1.0的二进制表示

首先，2.0e20会被当作double类型的数据进行处理，根据double变量的存储规则，它的底层二进制如下：

0-10001000010-0101101011110001110101111000101101011000110001000000

其中：

- 符号位：0

- 指数部分：10001000010

- 尾数部分：0101101011110001110101111000101101011000110001000000

插播一个小知识（不关心的可略过）：给定一个大数，它的二进制是如何计算得出的呢？

1. 首先，将$2 \times 10^{20}$进行质因式分解：
   
   $2 \times 10^{20} = 2 \times (2 \times 5)^{20} = 2^{21} \times 5^{20}$
   
   这表明，$2 \times 10^{20}$是由$2^{21}$和$5^{20}$的乘积构成，也就是说，这个大数的二进制形式可以看成5²⁰的二进制左移21位（即乘以2²¹），也就是说，我们需要求得$5^{20}$的二进制。

2. 求$5^{20}$的二进制：
   
   $5^{20}$的十进制为：95367431640625
   
   十进制求得二进制的过程，简单来说，即用95367431640625不断除以2，得到余数1或者余数0的一个竖向序列，将其倒序即是所求二进制。这里我直接写出二进制：
   
   10101101011110001110101111000101101011000110001（一共为47位）

3. 整体二进制表示：
   
   由上述计算可得知，$2 \times 10^{20}$的二进制为：
   
   $10101101011110001110101111000101101011000110001 \times 2^{21}$ 我们将其规范化，得到
   
   $1.0101101011110001110101111000101101011000110001 \times 2^{67}$

4. 求出了整体的二进制，double类型的具体存储就简单很多了。
   
   首先是指数部分：67 + 1023 = 1090，二进制为10001000010
   
   然后是尾数部分：直接提取小数点之后的部分，只有46位，还需要填充6个0即可（满足尾数52位的需求）

（小知识后咱们继续）其次，1.0也会被当作double类型来接收，底层二进制如下：

0 01111111111 0000000000000000000000000000000000000000000000000000

这个二进制就不详细说明了，相信有了前文的基础，读者可以轻松计算出来。

这里提供一套工具函数，用来打印float和double类型的二进制bit，用来验证很方便：

```
#include <stdio.h>
#include <stdint.h>

void print_bits_float(float f)
{
    union {
        float a;
        uint32_t b;
    }c;
    c.a = f;

    for (int i = 0; i < 32; i++) {
        printf("%d", c.b & 1 << (31 - i) ? 1 : 0);

        if (i == 0 || i == 8)
            printf(" ");
    }
    printf("\n");
}


void print_bits_double(double d) 
{
    union {
        double a;
        uint64_t b;
    }c;
    c.a = d;

    for (int i = 0; i < 64; i++) {
        //caution! 1ULL not 1 because 1 << or >> more than 31 is undefined behaviour.
        printf("%d", c.b & (1 ULL << (63 - i)) ? 1 : 0);

        if (i == 0 || i == 11)
            printf(" ");
    }
    printf("\n");
}
```

有了2.0e20 和 1.0的二进制以后，接着需要做浮点数的加法运算。

#### 2.0e20 + 1.0的浮点数加法运算

加法运算的第一个步骤叫**对阶**。什么叫对阶呢？就是把较小的指数对齐至另外较大的指数，方便计算。

比如：

$0.5_{10}$ + $0.4375_{10}$ ，下标代表进制，所以这里是十进制的0.5加十进制的0.4375

先把它们转化为二进制。$0.5_{10} = 1.0_{2} \times 2^{-1}$ 和  $0.4375_{10} = 1.11 \times 2^{-2}$

找到较小指数，即$1.11 \times 2^{-2}$（因为-2小于-1），将其指数-2对齐到较大的指数-1，对齐后变成这样：

$1.11 \times 2^{-2} = 0.111 \times 2^{-1}$ 。

这里要注意，因为指数变大了，所以小数点要左移相应的位数以保证数据正确。这个例子中，这两种表达方式对应的数据都是 $0.0111_{2}$。如果换算不清楚的，可以像这样，把不带指数的数据写出来对照一下，看你写的数据运算后是否和不带指数的数据一样。

若是这里有读者基础不好，没看懂，只要明白，二进制小数 * 2的N次幂的含义，应该就可以搞懂了，即当N大于0时，二进制小数 * 2的N次幂相当于把二进制小数的小数点右移N位；当N小于0时，二进制小数 * 2的N次幂相当于把小数点左移N位（联想下十进制就一定能搞懂了）



回到我们的代码，现在要加两个数2.0e20 和 1.0，前面已经讨论过了它们的二进制，接下来我们把它转化为规范化数：





对阶完毕后，第二个步骤叫**有效数相加**。大家都叫它尾数运算，但其实这个运算是要考虑前导1的，所以把它叫做有效数相加更容易理解。



1. 相加/相减

2. 把结果转换为规范数

| 阶段   | 关键变化点          | 结果状态         |
| ---- | -------------- | ------------ |
| 对阶前  | 指数差=9          | 1.0的尾数需要右移9位 |
| 对阶后  | 1.0尾数变为全零+超界低位 | 有效位完全丢失      |
| 加法运算 | 实际和=未改变的大数尾数   | 结果等于2.0e20   |
| 存储回写 | 无规格化或舍入需求      | 输出与输入相同      |


